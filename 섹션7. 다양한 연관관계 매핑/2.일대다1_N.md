## 1이 연관관계의 주인이다.

- 권장하지는 않는다.

## 일대다 단방향

Team이 1, Member가 N

Team의 List members가 member를 관리하고 싶다.

### 하지만 DB 테이블 입장에서는 Member에 Team_ID 가 외래키로 존재할 수 밖에 없음

```java
//class Team

@OneToMany
@JoinColumn(name = )
private List<Member> members = new ArrayList<>();
```

- 실행해보면, 쿼리가 많이 나간다. update 쿼리가 추가되었다.

```java
Member member  = new Member();

em.persist(member);

Team team = new Team();

team.getMembers().add(member);

em.persist(team);
```

- team의 List members에 새로운 member를 추가했다.

- 즉, 새로운 member가 team에 들어온 상황

- TEAM 엔티티를 저장하는데, MEMBER 테이블에 외래키로 들어간 부분은 어떻게 처리해야 하나?

- 옆 테이블(MEMBER)를 업데이트 update 하는 수 밖에 없다.

## 더 큰 문제점

- 내가 Team 테이블을 수정했는데 왜 Member 테이블에 update 쿼리가 들어가지?

- 나는 상관없는데, 다른 사람이 보면 이해가 어려움

- 실무 테이블이 한두개가 아님

- 운영이 어려워진다.

## 정리

1이 연관관계의 주인

- 항상 다N 쪽에 외래키가 있다.

- 객체와 테이블의 차이 때문에 반대편 테이블의 외래키를 관리해야 하는 특이한 구조

- JoinColumn 반드시 사용해야 하는데, 사용하지 않으면 Join Table 방식을 사용한다.

- 갑자기 Team_member 테이블이 생성됨.

## 단점

- 엔티티가 관리하는 외래키가 다른 테이블에 있다.

- 연관관계 관리를 위해 내가 아닌 옆 테이블에 UPDATE SQL을 실행한다.

`일대다 단방향 보다는 다대일 양방향 매핑을 사용하자`

## 일대다 양방향

```java
@JoinColumn(name = "TEAM_ID", insertable = false, updatable = false)
```

로 지정하면, 꼼수처럼 볼 수 있음

- 연관관계 주인처럼 설정되어 있음.
- 하지만 insertable, updatable을 false로 하면, 읽기만 한다.
- **읽기 전용 필드**를 사용하여 양방향 사용하는 방법

`일대다 단방향/양방향 보다는 다대일 양방향 매핑을 사용하자`
