# 1:1

- 그 반대도 일대일

- 주 테이블이나 대상 테이블 둘 중에 아무 곳에나 외래키를 선택할 수 있음

  - 주 테이블에 외래키

  - 대상 테이블에 외래키

- 외래 키에 데이터베이스 유니크 제약조건 추가 필요

## 일대일 : 주 테이블에 외래키 단방향

### Member vs Locker

- Member는 단 하나의 Locker를 가질 수 있다.

- 누가 외래키를 가지나 ? Member, Locker 둘다 가질 수 있음

- Member에 locker FK,UNI 가 있을 때...

## 다대일 처럼 만들고 @OneToOne으로 두면 똑같다.

## 대상 테이블에 외래키 단방향이 되나?

- 지원 되지 않음

## 외래키가 어디에 있어야 하나?

- Member vs Locker

- 내가 DBA라면, 나중에 비즈니스 룰이 변경될 때, Locker 에 외래키를 두는게 좋겠다. Uni만 바꾸면 됨

- 내가 개발자라면, Member에 Locker FK가 있는게 여러모로 유리하다. Locker 보단 Member를 조회 먼저하기 때문에 이미 가진 Locker값이 있음.

## 주 테이블에 외래키가 있을 때

- 주 객체가 대상 객체의 참조를 가지는 것 처럼, 주 테이블에 외래키를 두고 대상 테이블을 찾음

- 객체 지향 개발자가 선호

- JPA 매핑 관리

- 장점 : 주 테이블만 조회해도, 대상 테이블에 데이터가 있는지 확인 가능

- 단점 : 값이 없으면 외래키에 null 허용

## 대상 테이블에 외래키가 있을 때

- 대상 테이블에 외래키가 존재

- 전통적인 DBA가 선호

- 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다로 변경할 때, 테이블의 구조를 유지할 수 있다.

- 단점 : 프록시 기능의 한계로, 지연 로딩으로 설정해도 항상 즉시 로딩 됨

- 양방향으로 만들어야 할 것

## 프록시 객체란?

- 실제 객체를 대신하는 가짜 객체

- JPA에서 주로 지연로딩Lazy Loading 구현 위해 사용

- 당장 필요하지 않은  데이터를 바로 조회하는게 아니라 실제 사용 시점에 한번만 조회하는 것



### 프록시 동작 방식

- 프록시 객체는 실제 엔티티 클래스를 상속받아서 만들어진다. 겉모습, 사용방법이 실제 객체와 동일

- 조회 요청시, 지연 로딩이 설정되어 있다면, JPA는 실제 객체가 아니라 프록시 객체를 반환, SQL 쿼리 X

- 실제 사용시, 프록시 객체에는 실제 객체의 ID만 들어있기 때문에, 값을 가져와야 한다. 

- 즉, 이 시점에 프록시는 JPA를 통해 영속성 컨텍스트에 실제 엔티티 생성을 요청하고, SELECT 쿼리 전송

- 조회된 실제 객체와 자신(프록시 객체)를 연결하고, 요청받은 메서드를 실제 객체에 위임한다.



## 대상 테이블에 외래키가 있을 때 프록시의 한계

- 일대일관계에서 대상 테이블에 외래키가 있는 경우 지연로딩이 왜 되지 않는가?

- Member를 조회할 때, Locker를 지연 로딩으로 설정한 상황, 

- 외래키는 Locker에 있는 상황


### 문제

- JPA가 Member를 호출할 때, member.getLocker()의 결과로 Locker의 프록시를 넣어야 할지 null을 넣어야 할지 알 수 없다. Locker 테이블을 직접 조회해서 member_ID 외래키의 존재 여부를 확인하기 전까지 알 방법이 없음

- 결국 Locker가 있는지 확인하려면 Locker 테이블을 확인해야 하므로, JPA는 지연 로딩을 포기하고 즉시 로딩

