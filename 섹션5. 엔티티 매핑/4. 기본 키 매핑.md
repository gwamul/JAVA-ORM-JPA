## 기본 키 매핑

## @Id , @GeneratedValue

### @Id : 직접 할당

### @GeneratedValue : 자동 생성

### @GeneratedValue(strategy = ~)

- IDENTITY : 데이터베이스에 위임, MYSQL,

  - 난 모르겠고 DB 너가 알아서 해줘

- SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용, ORACLE

  - @SequenceGenerator 필요

  - call next value

  - 내가 원하는 규칙을 Generator 로 수정할 수 있음.

- TABLE : 키 생성용 테이블 사용, 모든 DB에서 사용

  - @TableGenerator 필요

  - 키 생성 전용 테이블을 하나 만드는 것

  - 테이블 하나를 만들어서 키를 거기서 뽑아온다.

  - 단점 : 성능, 운영할 때 쓰기엔 부담

  - 장점 : 모든 db에서 사용 가능

  - initialValue=

- 오라클 같은 경우 시퀀스 사용 : 자동으로 숫자 값을 넣어주는 형태

## 권장하는 식별자 전략

- 기본 키 제약 조건 : null이 아니고, 유일하며, 변하면 안된다.

- 이 애플리케이션이 존재하는 이상 절대 변하면 안되는 것
- 대체키 : 비즈니스적으로 사용할 수 있는 확실한 기본키

- PK를 주민번호로 쓰면, 그 회원 정보가 필요한모든 테이블에서 join 하며, 주민번호가 계속 공유됨

- UUID, 회사 내 랜덤 값, Long + 대체키

## IDENTITY 전략 - 매핑

```java
@GeneratedValue(strategy = GenerationType.IDENTITY)
```

- identity 전략은, id에 값을 넣지 않는다. 그 상태로 db에 insert한다.

- db에서는 null로 입력된 id 값을 받고, 그 때 값을 넣어준다.

- 문제 : id값을 알 수 있는 시점 : db에 들어간 후.

- 영속성 관리할 때, 무조건 PK값을 알고 있어야 한다. 그런데, PK값은 DB가 결정한다.

- 1차 캐시안에는 @Id 값을 모르고 있음.

- Identity 전략을 사용할 때, 울며 겨자먹기로 `em.persist(member)` 실행 시점에 바로 db에 insert query를 날린다.

- persist() 호출시 insert 쿼리를 날리고, JPA가 내부적으로 @Id값을 가지고 온다. (select 문 호출하는 건 아님, JDBC 내부적으로 값을 넣고, 바로 가져오는 형태로 구현)

- 다른 케이스는 commit 할 때 sql을 날리는데

무조건 키 값이 있어야

## SEQUENCE 전략 - 매핑

```java
@GeneratedValue(strategy = GenerationType.SEQUENCE)
```

- em.persist 하려면 pk를 알아야 하는데,

- sequence 전략이면, DB한테, 다음 seq 값을 알아오라고 한다.

- 시퀀스만 살짝 가져오는 형태
- 근데 네트워크 계속 왔다갔다 하는거 아닌가?

- Allocation size를 JPA가 가지고 있음, 미리 50개를 땡겨온다.

- 네트워크 호출 대신 메모리에서 값을 가져옴.

## TABLE 전략 - 매핑

- Allocation Size를 가지고 있음.
