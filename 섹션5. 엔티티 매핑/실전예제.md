# 1. 요구사항 분석, 매핑

- 회원은 상품을 주문할 수 있다.

- 주문 시 여러 종류의 상품을 선택할 수 있다.

## 기능

- 회원 기능

  - 회원 등록
  - 회원 조회

- 상품 기능

  - 상품 등록
  - 상품 수정
  - 상품 조회

- 주문 기능

  - 상품 주문
  - 주문 내역 조회
  - 주문 취소

## 도메인 모델 분석

- 회원과 주문의 관계 : 회원은 여러번 주문할 수 있다.(일대다)

- 주문과 상품의 관계 : 주문할 때 여러 상품을 주문할 수 있다.

- 주문 상품이라는 모델을 만들어서 다대다 관계를 1대1로

## 데이터 중심 설계의 문제점

- 객체 지향 설계는 각각의 객체가 맡은 역할과 책임이 있음

- 관련있는 객체끼릴 참조해야 한다.

- 이번 구현 방식은 객체 설계를 테이블 설계에 맞춘 방법.

- 테이블의 외래키를 객체 키 (member_id 등) 로 그대로 가져왔다.

- RDB에서는 연관 객체를 찾을 때 외래키를 사용하여 조인하면 되지만 객체에는 조인이라는 게 없기 때문.

- 객체는 연관된 객체를 찾을 때 참조를 사용

### 객체에서 참조가 아닌 데이터베이스의 외래 키를 그대로 가지고 있음

- order.getMember() 같은 객체 그래프를 탐색하거나 객체의 특성을 활용할 수 없다.

- 객체가 다른 객체를 참조하고 있지도 않다.

- UML이 잘못된 것.

- `객체는 외래키가  아니라 참조를 사용해야 한다.`

- 외래키만 가진 객체는 연관 Entity를 찾을 때 외래키로 다시 DB를 조회해야 한다.

- ex) 주문 조회 후, 다음 주문과 연관된 회원을 조회하기 위해 order를 db에서 찾고, 그 order가 가지고 있는 memberId를 구하고, db에서 member를 찾을 수 있다.

```java
Order order = em.find(Order.class, orderId);
Member  member = em.find(Member.class, order.getMemberId()); // 외래 키로 다시 조회
```

- 객체는 참조를 사용하여 연관관계를 조회할 수 있는게 장점임

```java
Order order = em.find(Order.class, orderId);
Member member  = order.getMember();;
```

## 정리

객체는 참조를 사용해서 연관된 객체를 찾고

테이블은 외래키를 사용해서 연관된 테이블을 찾는다.

- 둘 사이 큰 차이가 있음

- JPA를 쓰는 이유 : 객체의 참조와 테이블의 외래키를 `**매핑**`, 객체에서는 참조를 사용하여 구현, 테이블은 원래 db처럼 외리캐를 사용.

- 개발자가 객체지향과 RDB의 장점만 가질 수 있도록 해야 한다.
